# Jitsi setup with tokenAuthUrl

This guide is about a Jitsi setup with the following features:

- JWT based authentication on Jitsi
- There is an authentication system which generates tokens for Jitsi
- Each participant (_even guest_) has a token generated by the auth system
- Authentication flow based on `tokenAuthUrl`
- Waiting room for guest and member participants
- Moderator can join directly

## Installation

Assumed that Jitsi will run on Debian 12 VM. It is possible to apply the same
features on different environments.

### Basic Jitsi

Install a basic Jitsi without any customization using
[the official guide](https://jitsi.github.io/handbook/docs/devops-guide/devops-guide-quickstart).

### jitsi-meet-tokens

Install `jitsi-meet-tokens` package:

```bash
apt-get install jitsi-meet-tokens
```

### tokenAuthUrl

Set `tokenAuthUrl` in `config.js`. The link depends on how your authentication
system works:

```javascript
config.tokenAuthUrl = "https://auth.mydomain.com/auth.html?state={state}";
```

### Additional config for jitsi-meet

The following features are also set in `config.js` for our case:

```javascript
// Enable the prejoin page.
//
// The participant will be redirected to the authentication system after
// clicking "join meeting" button.
//
// The authentication system adds a hash (config.prejoinConfig.enabled=false)
// to the link to bypass the prejoin page after the authentication.

config.prejoinConfig = {
  enabled: true,
  hideDisplayName: true,
};

// Disable the deeplinking.
//
// The mobile participant will select her client-side environment (the mobile
// app or the mobile browser) after the authentication.
//
// The authentication system adds a hash (config.deeplinking.disabled=false) to
// the link to enable the deeplinking after the authentication.

config.deeplinking = {
  disabled: true,
};

// Enable autoKnock, so the participant will trigger the join attempt
// immediately when she comes to the waiting room
config.lobby = {
  autoKnock: true,
  enableChat: true,
};

// Disable the lobby password
config.securityUi = {
  disableLobbyPassword: true,
};
```

### Disable auto ownership

Disable the auto ownership in `Jicofo` to allow `token_affiliation` to manage
the ownership correctly.

```bash
hocon -f /etc/jitsi/jicofo/jicofo.conf set jicofo.conference.enable-auto-owner false
systemctl restart jicofo.service
```

### token_affiliation

This module will control the participant's level in a meeting depending on
`affiliation` field in the token payload.

Install and configure `token_affiliation` module:

```bash
cd /usr/share/jitsi-meet/prosody-plugins/
wget -O mod_token_affiliation.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/token_affiliation/mod_token_affiliation.lua
```

Enable the module in Prosody config:

```lua
Component "conference.meet.mydomain.com" "muc"
  modules_enabled = {
    "token_verification";
    "token_affiliation";
```

See
[token_affiliation](https://github.com/jitsi-contrib/prosody-plugins/tree/main/token_affiliation)
for details.

### muc_wait_for_host

This module is **NOT** used in this setup because it breaks the flow for our
case. It allows everyone to be a moderator if she has a token. So, even guest
participant can join the meeting directly if she has a token.

Therefore this setup implements the waiting room by using the following modules.

### lobby_autostart

This module will start the lobby automatically for each meeting. Only the
participant having a special value in her token payload will bypass this lobby.

Install and configure `lobby_autostart` module:

```bash
cd /usr/share/jitsi-meet/prosody-plugins/
wget -O mod_lobby_autostart.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/lobby_autostart/mod_lobby_autostart.lua
```

Enable the module in Prosody config:

```lua
Virtualhost "meet.mydomain.com"
  modules_enabled = {
    "muc_lobby_rooms";
    "persistent_lobby";
  }

Component "conference.meet.mydomain.com" "muc"
  modules_enabled = {
    "lobby_autostart";
  }
```

See
[lobby_autostart](https://github.com/jitsi-contrib/prosody-plugins/tree/main/lobby_autostart)
for details.

### token_lobby_bypass

This module allows the participant to bypass the lobby if she has a special
value (`"lobby_bypass" = true`) in her token payload.

Install and configure `token_lobby_bypass` module:

```bash
cd /usr/share/jitsi-meet/prosody-plugins/
wget -O mod_token_lobby_bypass.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/token_lobby_bypass/mod_token_lobby_bypass.lua
```

Enable the module in Prosody config:

```lua
Component "conference.meet.mydomain.com" "muc"
  modules_enabled = {
    "token_lobby_bypass";
  }
```

See
[token_lobby_bypass](https://github.com/jitsi-contrib/prosody-plugins/tree/main/token_lobby_bypass)
for details.

### lobby_deactivate

This module will deactivate the lobby after the first moderator joins the
meeting. So, the participants in the waiting room will join the meeting after
this stage without doing anything.

If the moderator has `context.room.lobby = true` in her token payload, the lobby
will be keeped even this module is enabled.

Install and configure `lobby_deactivate` module:

```bash
cd /usr/share/jitsi-meet/prosody-plugins/
wget -O mod_lobby_deactivate.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/lobby_deactivate/mod_lobby_deactivate.lua
```

Enable the module in Prosody config:

```lua
Component "conference.meet.mydomain.com" "muc"
  modules_enabled = {
    "lobby_deactivate";
  }
```

See
[lobby_deactivate](https://github.com/jitsi-contrib/prosody-plugins/tree/main/lobby_deactivate)
for details.

### Restart services

```bash
systemctl restart prosody.service
systemctl restart jicofo.service
```

## Token examples

### Guest

The guest participant has no account on the identity system but she has still a
token generated by the authentication system.

```json
{
  "aud": "myappid",
  "iss": "myappid",
  "sub": "*",
  "room": "*",
  "iat": 1731315029,
  "nbf": 1731314880,
  "exp": 1735649280,
  "context": {
    "user": {
      "name": "Guest",
      "affiliation": "member",
      "lobby_bypass": false
    }
  }
}
```

### Member

The member participant has an account on the identity system but no moderator
privileges.

```json
{
  "aud": "myappid",
  "iss": "myappid",
  "sub": "*",
  "room": "*",
  "iat": 1731315198,
  "nbf": 1731314880,
  "exp": 1735649280,
  "context": {
    "user": {
      "name": "Member",
      "affiliation": "member",
      "lobby_bypass": false
    }
  }
}
```

### Moderator (decativate the lobby)

This participant has an account on the identity system and moderator privileges.
She deactivates the lobby automatically after joining (_because there is no
`context.room.lobby` in her token_).

```json
{
  "aud": "myappid",
  "iss": "myappid",
  "sub": "*",
  "room": "*",
  "iat": 1731315464,
  "nbf": 1731314880,
  "exp": 1735649280,
  "context": {
    "user": {
      "name": "Moderator1",
      "affiliation": "owner",
      "lobby_bypass": true
    }
  }
}
```

### Moderator (keep the lobby)

This participant has an account on the identity system and moderator privileges.
She keeps the lobby after joining (_because there is `context.room.lobby` in her
token_).

```json
{
  "aud": "myappid",
  "iss": "myappid",
  "sub": "*",
  "room": "*",
  "iat": 1731315581,
  "nbf": 1731314880,
  "exp": 1735649280,
  "context": {
    "user": {
      "name": "Moderator2",
      "affiliation": "owner",
      "lobby_bypass": true
    },
    "room": {
      "lobby": true
    }
  }
}
```

## Hashes

The authentication system can add some hashes to the link to change the behavior
on Jitsi after the authentication.

The format of the generated link will be like the following in this case:

```
https://jitsi.domain.com/roomname?jwt=eyJh...#config.prejoinConfig.enabled=false
```

### Disabling prejoin

Add `config.prejoinConfig.enabled=false` to the link to disable the prejoin page
after authentication.

### Enable deeplinking

Add `config.deeplinking.disabled=false` to the link to enable the deeplinking
(_asking for selecting the app or the browser_) after authentication.
